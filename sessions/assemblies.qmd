---
title: "Assembly and Co-assembly of Metagenomic Raw Reads"
date: 2024-09-24
license: "Apache 2.0"
order: 2
author:
  - name: Germana Baldi
    orcid: 0000-0003-1719-5206
    email: germanab@ebi.ac.uk
    affiliation: 
      - name: EMBL-EBI
        url: www.ebi.ac.uk
  - name: Sonya Ochkalova
    email: sofia@ebi.ac.uk
    affiliation: 
      - name: EMBL-EBI
        url: www.ebi.ac.uk
---
--------------------------------------------------

# Learning Objectives

In the following exercises you will learn how to perform metagenomic assembly and co-assembly, and to start exploring the output. 
We will shortly observe assembly graphs with `Bandage`, peek into assembly statistics with `assembly_stats`, and align contig files against the BLAST database.

::: {.callout-note}
The process of metagenomic assembly can take hours, if not days, to complete on a normal sample, as it often requires days of CPU time and 100s of GB of memory. 
In this practical, we will only investigate very simple example datasets. 
:::

Once you have quality filtered your sequencing reads, you may want to perform *de novo* assembly in addition to, or as an alternative to, read-based analyses. 
The first step is to assemble your sequences into contigs. 
There are many tools available for this, such as `MetaVelvet`, `metaSPAdes`, `IDBA-UD`, or `MEGAHIT`. 

We generally use `metaSPAdes`, as in most cases it yields the best contig size statistics (i.e. more continguous assembly), and it has been shown to be able to capture high degrees of community diversity (Vollmers, et al. PLOS One 2017). 
However, you should consider pros and cons of different assemblers, which not only includes the accuracy of the assembly, but also their computational overhead. 
Compare these factors to what you have available. 

For example, very diverse samples with a lot of sequence data (e.g. samples from the soil) uses a lot of memory with SPAdes. 
In the following practicals we will demonstrate the use of `metaSPAdes` on a small short-read sample, `Flye` on a long-read sample, and `MEGAHIT` to perform co-assembly.

# Before we start...

Let’s first move to the root working directory to run all analyses:

```bash
cd /home/training/Assembly/
```

You will find all inputs needed for assemblies in the "`reads`" folders (both short and long). 

# Short-reads assemblies: metaSPAdes
For short reads, we will use [SPAdes - St. Petersburg genome Assembler](https://github.com/ablab/spades), a suite of assembling tools containing different assembly pipelines. 
For metagenomic data, we will the more metagenomic-specific side of `SPAdes`: `metaSPAdes`.

metaSPAdes offers many options that fit your preferences differently, mostly depending on the type of data you want to assemble.
To explore them, type `metaspades.py -h`. 
Bear in mind that options will differ when selecting different tools (e.g. spades.py) and they should be tuned according to the input dataset and desired outcome.

:::{.callout-tip}
The default metaSPAdes pipeline executes an error correction step on the input fastqs.
Since reads have already been polished in the past step, you can run metaspades without the error correction step.

You can see available metaspades parameters by typing the following: 
```bash
metaspades.py -h 
```
:::

:::{.callout-important}
This execution should be able to run on a 4-core, 32 GB ram laptop. However, we kindly ask you to NOT launch the execution on your VMs to prevent overload on the system if all VM users are running this command at the same time. The command will work if assembled correctly, but we kindly ask you to run it at a different moment. The execution would take around 15 minutes. 
:::

An explanation of involved parameters follows:

*    `-t 4` threads
*    `--only-assembler` skips the error correction step
*    `-m 10` memory limit in Gb
*    `-1 reads/oral_human_example_1_splitaa_trimmed_decontam.fastq` forward read
*    `-2 reads/oral_human_example_2_splitaa_trimmed_decontam.fastq` reverse read
*    `-o assembly_spades` output folder

Once the assembly has completed, all output files (including intermediate ones) can be found in the `assembly_spades` folder. 
`contigs.fasta` and `scaffolds.fasta` are the ones you are usually interested into for downstream analyses (e.g. binning and MAG generation). 
We will focus on `contigs.fasta` for this session, which is the same you are going to use in the coming practicals. 

Without having to go all the way down to MAGs, you can sometimes identify strong taxonomic signals at the assembly stage with a quick blastn alignment.

:::{.callout-step .callout-tip}
Take the first 100 lines of the sequence and perform a [blast](https://blast.ncbi.nlm.nih.gov/Blast.cgi) search (choose Nucleotide:Nucleotide from the set of options). 
Leave all other options as default on the search page. 
To select the first 100 lines of the assembly perform the following:

```bash
head -n 101 assembly_spades/contigs.fasta
```

The resulting output is going to look like this:
![Blast-n](assemblies/BLAST_assembly_spades_results.png)
:::

:::{.callout-question}
What species does this sequence seem to be coming from?

Does this make sense as a human oral bacterium? Are you surprised by this result at all?  
:::

As mentioned in the theory talk, you might be interested in different statistics for your contigs file. 
`assembly_stats` is a tool that produces two simple tables in JSON format with various measures, including N10 to N50, GC content, longest contig length and more. 
The first section of the JSON corresponds to the scaffolds in the assembly, while the second corresponds to the contigs.

:::{.callout-tip}
Contigs in this file are ordered from the longest to the shortest. 
:::

N50 is a measure to describe the quality of assembled genomes that are fragmented in contigs of different length, used to assess the sequence length of the shortest contig at 50% of the total assembly length (after sorting assembled contigs from longest to shortest). 

A (hopefully) clarifying picture to understand N50, where N50==60:
![N50](assemblies/N50.png){width="70%" height="70%"}

Essentially, the higher this value, the better, as it means that longer (i.e. more complete) contigs cover half of the final assembly.
However, this only makes sense when thinking about alike metagenomes. 

Note that, like N50, other values can be considered e.g. N90 is the shortest contig length to cover 90 percent of the metagenome. 

You can call `assembly_stats` with the following command:

:::{.callout-step .callout-tip}
```bash
assembly-stats assembly_spades/scaffolds.fasta
```
:::

You will see a short output with a few statistics for your assembly. 
In lines with format `N50 = YYY, n = Z`, `n` represents the amount of sequences needed to cover 50% of the total assembly.
A "gap" is any consecutive run of Ns (undetermined nucleotide bases) of any length. 
`N_count` is the total Ns (undetermined nucleotide bases) across the entire assembly.

:::{.callout-question .callout-tip}
What is the length of the longest and the shortest contigs? 

What is the N50 of the assembly? Given that input sequences were ~150bp long paired-end sequences, what does this tell you about the assembly?
:::

Another tool to keep in mind for metagenomic assemblies is QUAST, which provides a deeper insight on assemblies statistics like indels and misassemblies rate in a very short time.

# Long-reads assemblies: Flye

For long-reads, we will use [Flye](https://github.com/fenderglass/Flye), which assembles single-molecule sequencing reads like PacBio and Oxford Nanopore Technologies (ONT) reads. 
As SPAdes, Flye is a pipeline that takes care of assembly polishing. 
Similarly to assembly scaffolding, it tries to overcome long-reads base call error by comparing different reads that cover the same sequencing fragment. 

:::{.callout-tip}

Flye's parameters are quickly described in the help command:
```bash
flye -h
```

Flye supports metagenomic assemblies with the `--meta` flag. 
:::

The output for this section can be found in the `assembly_flye` folder. They have been generated with the following parameters:

* `--nano-raw`: depending on the quality of data, a different pre-set can be used. For example, if reads were previously polished and adapters were removed, we could use `--nano-corr`. `--nano-hq` should be reserved for high-quality data. 
* `long_reads/ONT_example.fastq` input raw reads file
* `--out-dir assembly_flye` output folder
* `--threads 4` number of threads

:::{.callout-note}
# Extra
Note that we did not use the `--meta` flag. 
You can also the result of using this flag in addition to the command above in the folder `assembly_flye_meta`.
:::

:::{.callout-warning}
As before, we recommend to NOT launch this command during this session. Each execution will take around 5 minutes.
:::

Let's have a first look at how assembly graphs look like.
Bandage (a Bioinformatics Application for Navigating De novo Assembly Graphs Easily) is a program that creates interactive visualisations of assembly graphs. 
They can be useful for finding sections of the graph, such as rRNA, or identify specific parts of a genome. 
Note, you can install Bandage on your local system. 
With Bandage, you can zoom and pan around the graph and search for sequences, and much more.

When looking at metaSPAdes output, it is usually recommended to launch Bandage on `assembly_graph.fastg`. 
However, our assembly is quite fragmented, so we will load `assembly_graph_after_simplification.gfa`.

We will use Bandage to compare the two assemblies we have generated, Flye and metaSPAdes.

:::{.callout-step .callout-tip}
```bash
Bandage
```

In the Bandage GUI perform the following:

- Select File -> Load graph
- Navigate to Home/training/Data/Assembly/assembly.bak and open `assembly_graph_after_simplification.gfa`

Once loaded, you need to draw the graph. 
To do so, under the “Graph drawing” panel on the left side perform the following:

- Set Scope to `Entire graph`
- Click on `Draw graph`
:::

:::{.callout-question .callout-tip}
Can you find any large, complex parts of the metaSPAdes graph? 
If so, what do they look like?
:::

:::{.callout-question .callout-tip}
How does the Flye assembly differ from the one generated with metaSPAdes?
:::

:::{.callout-note}
# Extra
We launched Flye both with and without `--meta` on file `reads/ONT_example.fastq`.
This file actually comes from run ERR3775163, which can be browsed on [ENA](https://www.ebi.ac.uk/ena/browser/home). 
Have a look at sample metadata.
Despite dealing with a long-read sample, can you understand why the assembly graph looks better for the execution without the `--meta` option?
:::

:::{.callout-note}
# Extra
If you blast the first contig of the long-read assembly, do results match the metadata you find on ENA?
:::

# Co-assemblies: MEGAHIT

In the following steps of this exercise, we will perform co-assembly of multiple datasets. 
The first execution requires around 6-7 minutes to finish, the general suggestion is to run the first instruction and then rely on files in the **coassembly.bak** directory, which contains all expected results.

:::{.callout-step .callout-tip}
First, make sure that output directories do not already exist, as MEGAHIT can't overwrite existing directories. 
Bear in mind that backup assemblies for this exercise are in:

```bash
ls /home/training/Assembly/coassembly.bak
```

You can perform co-assemblies with MEGAHIT as follows:

```bash
megahit -1 reads/oral_human_example_1_splitaa_kneaddata_paired_1.fastq -2 reads/oral_human_example_1_splitaa_kneaddata_paired_2.fastq -o coassembly1_new -t 4 --k-list 23,51,77 

megahit -1 reads/oral_human_example_1_splitaa_kneaddata_paired_1.fastq,reads/oral_human_example_1_splitab_kneaddata_paired_1.fastq -2 reads/oral_human_example_1_splitaa_kneaddata_paired_2.fastq,reads/oral_human_example_1_splitab_kneaddata_paired_2.fastq -o coassembly2_new -t 4 --k-list 23,51,77 

megahit -1 reads/oral_human_example_1_splitaa_kneaddata_paired_1.fastq,reads/oral_human_example_1_splitab_kneaddata_paired_1.fastq,reads/oral_human_example_1_splitac_kneaddata_paired_1.fastq -2 reads/oral_human_example_1_splitaa_kneaddata_paired_2.fastq,reads/oral_human_example_1_splitab_kneaddata_paired_2.fastq,reads/oral_human_example_1_splitac_kneaddata_paired_2.fastq -o coassembly3_new -t 4 --k-list 23,51,77
```
:::

You should now have three different co-assemblies generated from different subsamples of the same data.

:::{.callout-step .callout-tip}
Compare the results of the three contig files with `assembly_stats`. 
How do these assemblies differ from the one generated previously with metaSPAdes? 
Which one do you think is best?

To generate assembly graphs for MEGAHIT output, execute:
```bash
megahit_toolkit contig2fastg 77 final.contigs.fa > final.contigs.fastg
```
:::

# ... And now?
If you have reached the end of the practical and have some spare time, look at the paragraphs labelled "Extra". 
They contain optional exercises for the curious student :)

# ........ Yes, but now that I am really, really done?
You could try to assemble raw reads with different assemblers or parameters, and compare statistics and assembly graphs. 
Note, for example, that metaSPAdes can deal ONT data (but it will likely yield a lower quality assembly). 
